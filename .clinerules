# Coslate
### Coslate means collaborative translate - humans and AIs together.

This project is a template for a translation - both long and short, weak and strong.

## AI Installation and Customization
When a user clones this template repository and opens it with an AI agent (currently VSCode with Roo Code and Claude Sonnet 3.5 or 3.7), the AI should guide the user through the following installation and customization process:

1. **Initial Project Understanding**:
   - Ask the user about the source material to be translated (type, length, language, complexity).
   - Inquire about the target language and audience.
   - Understand the user's translation goals and any specific requirements.

2. **Project Configuration**:
   - Determine the paragraph ID format for the project (e.g., 01.01 for first document, first paragraph).
   - Establish file naming conventions for the translation workflow (*.done.md, *.proof.md, *.red.md).
   - Decide on the final output format(s) needed (HTML, EPUB, PDF, etc.).

3. **Style Definition**:
   - Work with the user to define the translation style and approach.
   - Update `./prompts/Style.md` with detailed guidelines about:
     - How closely to follow the original text's style
     - Handling of cultural references
     - Treatment of idioms and metaphors
     - Voice and tone preferences
     - Any specific terminology requirements

4. **Documentation Updates**:
   - Update the README.md with a comprehensive project description.
   - Modify these .clinerules to reflect the specific translation project.
   - Create or update necessary documentation in the ./docs folder.

5. **Technical Setup**:
   - Configure VSCode tasks for compilation and preview.
   - Set up GitHub Actions for automated builds if needed.
   - Install and configure any necessary Python packages via Poetry.

6. **AI Role Definition**:
   - Define the specific AI roles needed for this translation project.
   - Create appropriate prompts in the ./prompts folder for each role.

The AI should document all decisions and configurations made during this process, ensuring the project is fully set up and ready for translation work to begin.

## Developing Coslate
We have ./memlog, where we save in datetime stamped files overall information about what work was successfully done (finished, tested, documentation updated is the definition of done for the template part of the project).

Plans on what should be done go into ./memlog/*-plan.md files and we keep it precise and current by marking sections as completed and cleaning up things once some larger unit of work is done. 

We have a main ./Plan.md, which we maintain at the end of every successful session to link sub-plan.md files in ./memlog and mark what has been done. 

Our aim is to have the user clone this template repo and collaborate with an AI agent to create a customized translation environment. The AI should help the user determine what the resulting product should be and what the presentation should look like, by suggesting prompt improvements. Whatever the final product should be (markdown files merged into one and turned into HTML probably), the AI should suggest updating or creating mechanisms for automatic compilation and publication with VSCode tasks, GitHub Actions and possibly other pipelines.

But before we get there, we need to set up the template itself, since this project here - starting with these .clinerules, README.md that will hold the gist of it, ./docs/ folder, where we will store reference literature, translation memory and other useful things for both the template development and the translation itself.

Part of this template project should be ./prompts, because the AI agents working on this projects will need to be able to take on several separate roles - exquisite literary translator, who is able to take the spirit of the original and infuse the translation with its own version of the spirit, empathetic and attentive redactor, who sees where the tired eye left too forced a translation and where things could be improved, godlike proofreader who knows all the grammar (helps to have all the rules for your language in ./docs/grammar)... 

And we should also make is self-contained as much as possible, so we'll have some Python 3.12 managed via Poetry with packages installed into the project folder, all in ./scripts and possibly ./bin for other tools.

We should have VSCode tasks, that will run scripts to compile whatever is in ./src (suggestion is to have 10_Chapter_001_Home.md, 20_Chapter_002_Journey.md etc.) into a single file in ./pub, then maybe convert it to HTML using some ./templates, have a way to save it as EPUB.

Don't hesitate to list files in folders and search for strings, the filenames should be explanatory, and include anything that looks like it could be pertinent.

When translating, we see to filenames (*.done.md is already finished, *.proof.md is in need of proofreading, *.red.md would be for redaction) where to start.

when there's some term we might need to note the translation of, to create a translation memory in ./src/{lang}/TranslationMemory.md which we too can load at the beginning of working on translation and redaction.

# .MD File Format
In the beginning, there is only the original, lets say just 01.md, 02.md and 03.md. 

We take 01.md, read all the context we could use from ./docs etc. And we start working paragraph by paragraph, section by section - first we put the original part as a Markdown comment (example on following line):
[//]: # ( comment text )
And then after the original paragraph we insert a line after with another comment, marking the id of the paragraph - depends on project and should be decided by the user during the install process with AI in the beginning. In our case, it's 01.01 - first document, first paragraph. When we meet an empty paragraph, we just add an empty line, when there are three, we add a hr element using dashes.
Then come other optional comments - for more complex paragraphs, we might need a longer deliberation of what options the translation has, and then deciding according to the ./prompts/Style.md - all in the comments under paragraph id.
And then comes the polished translation, with footnotes where we include something, which might not be obvious to the reader. 
And after that, we have another paragraph in original, so anytime we stop, we can see which is the last paragraph to have a translation, and the resulting artifacts can be compiled anytime and both the translated part and the unfinished part will be readable.

Ignore paragraph numbering inconsistencies.

## Footnotes
Here's a simple footnote[^{part_id.paragraph_id.note_id}].

We name footnotes with the id of the part and paragraph and note, not just incrementally numbered 

[^{part_id.paragraph_id.note_id}]: Here's one with multiple paragraphs and code.

    Indent paragraphs to include them in the footnote.

    `{ my code }`

    Add as many paragraphs as you like.
 
Media files go in ./src/media/{lang}/ for language-specific media files

## AI roles

### Available Modes

The project uses several specialized AI modes, each with specific capabilities:

#### Translator Mode
Primary mode for translation work. Switch to this mode when:
- Starting new translations
- Updating existing translations based on feedback
- Responding to editor comments
- Adding translator footnotes and comments

#### Editor Mode
For reviewing and improving translations. Switch to this mode when:
- Reviewing completed translations
- Providing feedback on translation quality
- Making direct corrections
- Ensuring consistency across translations
- Adding editor footnotes and comments

#### Project Assistant Mode
For project management and organization. Switch to this mode when:
- Creating or updating project documentation
- Managing work progress in ./memlog
- Creating monthly summaries
- Identifying improvements or issues
- Coordinating between roles

#### Researcher Mode
For historical research and document preparation. Switch to this mode when:
- Working with original scans and preparing raw markdown files
- Breaking down raw documents into properly formatted daily entries
- Researching historical context, people, places, and cultural references
- Creating glossary entries in /src/_original/_glossary/ with filenames matching hashtags
- Maintaining documentation of historical context


# File Structure

The project has a specific file structure that should be maintained:

- `/src`: Contains the translation files
  - `/{lang}`: Language-specific directories (e.g., `/src/cz/` for Czech)
    - `/00`, `/01`, etc.: Book/chapter directories
    - `TranslationMemory.md`: Language-specific translation memory
    - `Style.{lang}.md`: Language-specific style guide
  - `/_original`: Original source materials
    - `/00`, `/01`, etc.: Book/chapter directories
    - `/_glossary`: Research notes on specific topics, with filenames matching hashtags
    - `/_summary`: Monthly summaries of diary content
  - `/media`: Media files
    - `/{lang}`: Language-specific media files
  - `HASHTAGS.md`: Alphabetical list of hashtags, each linked to its glossary file

- `/prompts`: Contains project-specific prompts
  - `original_text_preparation.md`: Instructions for preparing original text
  - `Work.md`: Information about the source material
  - Other project-specific prompts

- `/docs`: Contains reference materials

- `/memlog`: Contains logs of completed work and plans

- `/pub`: Contains compiled output files

- `/scripts`: Contains Python scripts for compilation

- `/bin`: Contains executable tools

# Hashtag System

When a paragraph mentions a topic of interest (person, event, place, etc.):

1. Create a hashtag in `src/HASHTAGS.md` - an alphabetical list of hashtags, each linked to its glossary file
2. Create a corresponding file in `/src/_original/_glossary/` with filename matching the hashtag (e.g., `Emile_Zola.md`)
3. When using hashtags in paragraph comments, format them as markdown links to their topic files in _glossary
4. This allows translations to maintain the same filenames while translating the contents

# Monthly Summaries

## Purpose

To maintain context across the translation project, we create monthly summaries of Marie Bashkirtseff's diary entries. These summaries are written in English and provide an overview of:

- Main topics and themes
- Key events
- People mentioned
- Social and cultural context
- Marie's personal development
- Setting details

## Location

Monthly summaries are stored in the `src/_original/_summary/` directory with filenames following the pattern `YYYY-MM.md` (e.g., `1873-01.md` for January 1873).

## Usage

These summaries serve several important purposes:

1. **Context Preservation**: They ensure that translators working on later months understand references to people, events, and themes from earlier entries.

2. **Thematic Tracking**: They help track the development of recurring themes and relationships across the diary.

3. **Translation Consistency**: They support consistent translation of names, places, and recurring concepts.

4. **Reader Aids**: They can be incorporated into published versions as chapter introductions or appendices.

## Creation Process

At the end of translating each month's entries, a summary is created that captures:

- The main narrative threads
- Important character developments
- Social events and settings
- Emotional and intellectual themes

These summaries are written in English to serve as a reference for translators working in any target language.

## Example

See `src/_original/_summary/1873-01.md` for an example of a monthly summary for January 1873, which covers Marie's growing fascination with the Duke of Hamilton, social events in Nice during the winter season, and her personal development.